<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Introduction</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引へ戻る</a></div>


<h1>CoffeeScriptって何?</h1>

<p><a href="http://coffeescript.org">CoffeeScript</a>はJavaScriptにコンパイルできる小さな言語です。文法がRubyとPythonに影響を受けていてそれらの2つの言語の多くの機能を実装しています。この本はあなたがCoffeeScriptを学習し、ベストプラクティスを理解し、優れたクライアントサイドアプリケーションの開発を開始するのを手助けします。この本は小さく、5章しかありません。しかしそれは適切なことでしょう！CoffeeScriptもまた小さな言語ですから。</p>

<p>この本は完全なオープンソースです。<a href="http://alexmaccaw.co.uk">Alex MacCaw</a> (または <a href="http://twitter.com/maccman">@maccman</a>)により書かれました。また次の人々より大きなご協力を頂きました。<a href="https://github.com/dxgriffiths">David Griffiths</a>, <a href="http://github.com/satyr">Satoshi Murakami</a>, そして<a href="https://github.com/jashkenas">Jeremy Ashkenas</a>です.</p>

<p>もしあなたが間違いや提案をお持ちならどうぞためらわずにこの本のgithubページ <a href="https://github.com/arcturo/library">GitHub page</a>.にてチケットをオープンして下さい。また読者は私が書いた別の本、 <a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications by O'Reilly</a>にも興味を持たれるかもしれません。こちらの本はリッチなJavaScriptアプリケーションや状態をクライアントサイドに移動させることについて説明しています。</p>

<p>それでは始めましょう。なぜCoffeeScriptを書くことは純粋なJavaScriptを書くよりも良いことなのでしょうか? 最初に上げられるのはコードの記述量が減ることです。CoffeeScriptはとても簡潔で、また空白を頼りにします。私の経験ではこれによりコードはオリジナルのJavaScriptに比べて3分の1から半分になります。さらにCoffeeScriptにはいくつかの素敵な機能があります。例えば配列の内包記述やプロトタイプエイリアス、クラスなどがあり、それらはあなたに必要なタイプ量をさらに減らします。</p>

<p>もっと重要なことは、JavaScriptには多くの悩みの種<a href="http://bonsaiden.github.com/JavaScript-Garden/">skeletons in its closet</a>が存在し、多くの初心者をつまづかせます。CoffeeScriptはJavaScriptの機能から選抜された機能を用い、多くのおかしな点を直すことでかっこよくそれらを避けてしまいます。</p>

<p>CoffeeScriptはJavaScriptの拡張ではありません。そのためCoffeeScriptの中でJavaScriptの外部ライブラリを使用可能とは言え、JavaScriptを変換無しにそのまま用いればシンタックスエラーとなります。コンパイラはCoffeeScriptのコードを対応するJavaScriptに変換しますので実行時に翻訳はしません。</p>

<p>最初によくある誤解を解きましょう。CoffeeScriptを書くためにはJavaScriptを理解しなければならない。実行時エラーがJavaScriptの知識を要求するためです。しかしながらその事を言うなら、実行時エラーは普通、とても自明的です。そのため私はJavaScriptをCoffeeScriptに戻すことを問題に感じたことはありません。2つ目の問題として私が良く聞くのはCoffeeScriptの実行速度に関するものです。つまりCoffeeScriptのコンパイラが生成したコードは同等なJavaScriptよりも遅いというものです。しかし実際にはそれもまた問題ではありません。CoffeeScriptは手で書いたJavaScriptよりと同等に、またはより速く動作する傾向があります。</p>

<p>CoffeeScriptを使用することの欠点は何でしょうか? そう、それはあなたとあなたのJavaScriptの間にまた別のコンパイルステップを挿入することです。CoffeeScriptは、できうる限り明快で理解しやすいJavaScriptを生成し、サーバーとの統合によるコンパイルの自動化にてその問題を軽減します。他の欠点として、他のどんな新しい言語でもそうですが、コミュニティが現時点では小さいことが挙げられます。あなたは既に詳しい協力者を得るのに苦労するでしょう。しかしCoffeeScriptは急速に勢いを得ています。IRCリストは充実していますのであなたのどんな問題も通常は適切に解答を得ることができるでしょう。</p>

<p>CoffeeScript is not limited to the browser, and can be used to great effect in server side JavaScript implementations, such as <a href="http://nodejs.org/">Node.js</a>.   Additionally, CoffeeScript is getting much wider use and integration, such as being a default in Rails 3.1. Now is definitely the time to jump on the CoffeeScript train. The time you invest in learning about the language now will be repaid by major time savings later.
CoffeeScriptはブラウザに限定されません。<a href="http://nodejs.org/">Node.js</a>のようなJavaScriptのサーバーサイド実装でも大きな効果を得ることができるでしょう。加えてCoffeeScriptはより広い範囲での使用や統合を得ています。例えばRails3.1ではデフォルトとなりました。今がCoffeeScripitという列車に飛び乗るのに絶好の時です。今この言語を学習する時間の投資は後に多くの時間を節約することとして返還されるでしょう。</p>

<h2>最初のセットアップ</h2>

<p>初めに試してみる最も簡単な方法はブラウザを用いる方法です。<a href="http://coffeescript.org">http://coffeescript.org</a>を開いて<em>Try CoffeeScript</em>をクリックして下さい。このサイトはブラウザ版のCoffeeScriptコンパイラを用いています。左側のパネルに入力した任意のCoffeeScriptを右側のパネルにJavaScriptとして変換します。</p>

<p>JavaScriptからCoffeeScriptに戻す変換を行うことも<a href="http://js2coffee.org/">js2coffee</a>プロジェクトを用いて可能です。JavaScriptのプロジェクトをCoffeeScriptに移行する場合に特に便利です。</p>

<p>実際にブラウザ版のCoffeeScriptコンパイラをあなた自身が用いることも可能です。<a href="http://jashkenas.github.com/coffee-script/extras/coffee-script.js">this script</a>をページに入れ、任意のCoffeeScriptをscriptタグと正しい型で記します。</p>

<pre><code>&lt;script src="http://jashkenas.github.com/coffee-script/extras/coffee-script.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script type="text/coffeescript"&gt;
  # Some CoffeeScript
&lt;/script&gt;
</code></pre>

<p>明らかに、実際の運用では実行時にCoffeeScriptを翻訳したくはないでしょう。あなたのクライアントに対し全てを遅くしてしまいます。その代わりとして、CoffeeScriptは <a href="http://nodejs.org">Node.js</a>コンパイラを事前にCoffeeScriptファイルを処理するために提供します。</p>

<p>インストールするためにはまず最新の安定版の<a href="http://nodejs.org">Node.js</a>と<a href="http://npmjs.org/">npm</a> (the Node Package Manager)を持っているか確認してください。そうしたら次にnpmを用いてCoffeeScriptをインストールします。</p>

<pre><code>npm install -g coffee-script
</code></pre>

<p>こうすることで実行コマンド<code>coffee</code>を得ます。コマンドラインオプションを与えずに実行するとCoffeeScriptのコンソールに入りCoffeeScriptの文を手早く実行することが可能です。ファイルのコンパイルを行うには<code>--compile</code>オプションを与えます。</p>

<pre><code>coffee --compile my-script.coffee
</code></pre>

<p><code>--output</code>が指定されていなければ、CoffeeScriptはJavaScriptファイルを同じ名前で作成します。この場合には<code>my-script.js</code>です。既存のファイルは上書きしますので不注意に存在するJavaScriptファイルを上書きしないよう注意してください。コマンドラインオプションの完全なリストを得るためには<code>--help</code>を与えます。</p>

<p>上で見られるように、CoffeeScriptのデフォルト拡張子は<code>.coffee</code>です。このことが<a href="http://macromates.com/">TextMate</a>のようなテキストエディタにそのファイルがどの言語を保持しているのか理解させ、適切な構文ハイライトの提供を可能にします。デフォルトではTextMateはCoffeeScriptをサポートしません。しかしbundle<a href="https://github.com/jashkenas/coffee-script-tmbundle">bundle to do so</a> を用いて簡単にインストール可能です。</p>

<p>もしここまでのコンパイルが少しばり不便で面倒に感じたとしても、それはその通りだからです。私達は後程、CoffeeScriptファイルを自動的にコンパイルすることでその問題を解決します。でもまずは言語の文法を見てみましょう。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Syntax</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>CoffeeScriptの文法</h1>

<p>最初にこのセクションを始める前に再確認しておきましょう。CoffeeScriptの文法はしばしばJavaScriptと同じですが拡張ではありません。従っていくらかのJavaScriptのキーワード、例えば<code>function</code>や<code>var</code>は許されません。文法エラーになります。CoffeeScriptのファイルを書くのであれば純粋にCoffeeScriptである必要があります。2つの言語を混ぜることはできません。</p>

<p>なぜCoffeeScriptは拡張ではないのでしょうか? それはCoffeeScriptプログラムの空白が重要であることが、拡張であることを妨げるからです。その決定が行われてからはチームはあなたもまたそれに完璧に従いJavaScriptのいくつかのキーワードを非推奨として扱うことを、簡潔さの掟とよくあるバグを減らすための努力の名の元に行うよう決定したのです。</p>

<p>メタ的な意味で驚いたのはCoffeeScriptインタプリタ自身が実際にCoffeeScriptで書かれていたことでした。それは卵と鶏のパラドックスがついに解決したかに見えました！</p>

<p>さて、それでは最初に基本的な事柄に取り掛かりましょう。CoffeeScriptにはセミコロンがありません。コンパイル時に自動的に追加してくれます。セミコロンはJavaScriptコミュニティにおいて、いくつかのおかしなインタプリタの挙動<a href="http://bonsaiden.github.com/JavaScript-Garden/#core.semicolon">behavior</a>により多くの議論の的でした。とにかく、CoffeeScriptはこの問題を単純にセミコロンを文法から消し、状況により追加することで解決しました。</p>

<p>コメントはRubyのコメントと同じフォーマットです。ハッシュ文字(<code>#</code>:通称、シャープ)で始めます。</p>

<pre><code># これはコメント
</code></pre>

<p>複数行のコメントもまたサポートされており、生成されたJavaScriptに適用されます。3つのシャープで括ります。</p>

<p><span class="csscript"></span></p>

<pre><code>###
  複数行のコメント。たぶん、ライセンス
###
</code></pre>

<p>既に手短に説明しましたが、CoffeeScriptでは空白が重要です。実際に、これは中括弧(<code>{}</code>)をタブで置き換えられることを意味します。これはPythonの文法からインスピレーションを得ており、あなたのスクリプトが同じ様式で整形される保障という素敵な副作用を持っています。そうしなければコンパイルもできません！</p>

<h2>変数とスコープ</h2>

<p>CoffeeScriptはJavaScriptの主な問題の1つを直しました。グローバル変数です。JavaScriptでは変数宣言の前に<code>var</code>を置くのを忘れてしまったために不本意にグローバル変数を宣言してしまうことが頻繁でした。CoffeeScriptはこれを単純にグローバル変数を無くすことで解決しています。裏側ではCoffeeScriptはスクリプトを無名関数でラップすることでローカルコンテキストを保持しています。そして自動的に全ての変数宣言に<code>var</code>を付けています。例えば次の単純な変数の割当をご覧下さい。</p>

<p><span class="csscript"></span></p>

<pre><code>myVariable = "test"
</code></pre>

<p>上のコード例の右上にダークグレーの箱があるのに気付かれますでしょうか。それをクリックしてください。コードはCoffeeScriptとコンパイルされたJavaScriptとでスィッチします。これはページの丁度中で実行時に描かれています。そのためコンパイルされた出力が正しいことを確認できるでしょう。</p>

<p>ご覧になられたとおり、変数の割当は完全にローカルに保持されます。グローバル変数を事故で作ることは不可能です。CoffeeScriptは実際にこのステップを延長し、高いレベルの変数を隠すことを難しくしています。このことがJavaScriptにおいて開発者が最も一般的に行ってしまう誤りのいくつかを防ぐ良い取り決めとなっています。</p>

<p>しかしながら、時々、グローバル変数を作ることは便利な事です。グローバルオブジェクト(ブラウザでは<code>window</code>)のプロパティとして直接設定するか、次のパターンを用いることで可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>exports = this
exports.MyVariable = "foo-bar"
</code></pre>

<p>rootコンテキストでは<code>this</code>はグローバルオブジェクトに等しくなります。<code>exports</code>という名の変数を作成することで、あなたのコードを読む誰にとってもスクリプトがどんなグローバル変数を作っているかが明らかになるでしょう。加えて、CommonJSモジュールについて可能とします。この本では後でその事についてもカバーします。</p>

<h2>関数</h2>

<p>CoffeeScriptはとても冗長なfunction文を削除しました。そしてそれを細い矢印:<code>-&gt;</code>で置き換えました。関数は1行でも良いし、インデントを行って複数行記述も可能です。関数の最後の式が暗黙的に返り値となります。つまり<code>return</code>文を使う必要がありません。関数の途中で返り値を返したい場合には使うことも可能です。</p>

<p>そのことを頭に入れて、次の例を見てみましょう:</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt; "bar"
</code></pre>

<p>コンパイルの結果が、<code>-&gt;</code>が<code>function</code>になるのが見えると思います。そして<code>"bar"</code>という文字列が自動的にreturnされるのもおわかりでしょうか。</p>

<p>先程お話しましたとおり、複数行を問題無く使うことができます。ただし適切に関数の本体をインデントする必要があります。</p>

<p><span class="csscript"></span></p>

<pre><code>func = -&gt;
  # 余分な行
  "bar"
</code></pre>

<h3>関数引数</h3>

<p>引数はどうやって指定するのでしょうか？CoffeeScriptでは矢印の前で、括弧の中に引数を指定します。</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a, b) -&gt; a * b
</code></pre>

<p>CoffeeScriptはデフォルト引数もサポートします。例えば：</p>

<p><span class="csscript"></span></p>

<pre><code>times = (a = 1, b = 2) -&gt; a * b
</code></pre>

<p>また可変長引数を利用するのにスプラットを用いることも可能です。<code>...</code>の名称です。</p>

<p><span class="csscript"></span></p>

<pre><code>sum = (nums...) -&gt; 
  result = 0
  nums.forEach (n) -&gt; result += n
  result
</code></pre>

<p>上の例では<code>nums</code>は関数に渡された全ての引数の配列です。これは<code>arguments</code>オブジェクトではありません。そうではなく本物の配列です。だからこれを取り扱うのに<code>Array.prototype.splice</code>や<code>jQuery.makeArray()</code>の使用をあなた自身で考慮する必要がありません。</p>

<p><span class="csscript"></span></p>

<pre><code>trigger = (events...) -&gt;
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
</code></pre>

<h3>関数の実行</h3>

<p>関数はJavaScriptと全く同じように実行することが可能です。括弧<code>()</code>を付けたり、<code>apply()</code>を適用したり、<code>call()</code>を呼んだりです。しかしRubyのように、CoffeeScriptは関数が最低一つの引数と実行されれば、自動的に関数を呼出します。</p>

<p><span class="csscript"></span></p>

<pre><code>a = "Howdy!"

alert a
# 次と同じ
alert(a)

alert inspect a
# 次と同じ
alert(inspect(a))
</code></pre>

<p>括弧は必須ではありませんが、直ぐに何がどんな引数と実行されるか明らかに判る場合以外は使用することをお勧めします。<code>inspect</code>を用いる最後の例では、私は最低でも<code>inspect</code>の実行には括弧を付けることを強くお勧めします。</p>

<p><span class="csscript"></span></p>

<pre><code>alert inspect(a)
</code></pre>

<p>もし実行時に1つも引数を渡さない場合、CoffeeScriptはあなたが関数の実行を意味しているのか、変数として取り扱って欲しいのか理解できません。この事実より、CoffeeScriptの処理は常に関数参照を実行するRubyとは異なり、Pythonにより近いものとなっています。このことが私のCoffeeScriptプログラムではいくつかのエラーの元となりました。従ってあなたが引数無しで関数を起動する場合には十分に気を付けて括弧を付けましょう。</p>

<h3>関数コンテキスト</h3>

<p>コンテキストの変化はJavaScriptにおいて嫌なものです。特にイベントコールバックにおいては顕著です。そのためCoffeeScriptではこれを管理するためにいくらか助けとなるものを用意しました。そのようなヘルパーの一つが<code>-&gt;</code>のバリエーションである太った矢印(ファットアロー)<code>=&gt;</code>の関数です。</p>

<p>細い矢印の代わりにファットアローを用いることで、関数のコンテキストがローカルのものに紐付けられることを確実にします。以下の例をご覧下さい。</p>

<p><span class="csscript"></span></p>

<pre><code>this.clickHandler = -&gt; alert "clicked"
element.addEventListener "click", (e) =&gt; this.clickHandler(e)
</code></pre>

<p>これを行いたい理由は<code>addEventListener()</code>からのコールバックは<code>element</code>のコンテキストにて実行されるからです。すなわち<code>this</code>は<code>element</code>に等しくなります。もしあなたが<code>self = this</code>のような面倒をせずに<code>this</code>をローカルコンテキストに保持したい場合にはファットアローを用います。</p>

<p>このバインディングのアイデアはjQueryの<a href="http://api.jquery.com/jQuery.proxy/"><code>proxy()</code></a>や<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">ES5</a>の<code>bind()</code>関数と似たコンセプトです。</p>

<h2>オブジェクトの構文と配列の定義</h2>

<p>オブジェクト構文はJavaScriptと全く同じように指定可能です。中括弧のペアやキー/バリューの文を使います。しかし関数実行と同じように、CoffeeScriptは中括弧を省略可能です。実際に、インデントをまた使うことが可能ですし、改行をカンマの変わりに用いることができます。</p>

<p><span class="csscript"></span></p>

<pre><code>object1 = {one: 1, two: 2}

# 中括弧無しで
object2 = one: 1, two: 2

# 改行をカンマの変わりにする
object3 = 
  one: 1
  two: 2

User.create(name: "John Smith")
</code></pre>

<p>同様に、配列は空白をカンマの代わりに区切に用いることができます。ただし角括弧(<code>[]</code>)は必須です。</p>

<p><span class="csscript"></span></p>

<pre><code>array1 = [1, 2, 3]

array2 = [
  1
  2
  3
]

array3 = [1,2,3,]
</code></pre>

<p>上の<code>array3</code>の例でわかるようにCoffeeScriptは最後のカンマ(<code>trailing comma</code>)を取り除いています。これもまた良くあるクロスブラウザでのエラーの元です。</p>

<h2>フローコントロール</h2>

<p>CoffeeScriptの括弧が必須でないというお約束は<code>if</code>と<code>else</code>キーワードでも続きます。</p>

<p><span class="csscript"></span></p>

<pre><code>if true == true
  "We're ok"

if true != true then "Panic"

# 以下と同じ意味
#  (1 &gt; 0) ? "Ok" : "Y2K!"
if 1 &gt; 0 then "Ok" else "Y2K!"
</code></pre>

<p>上でわかりますように、もし<code>if</code>文が1行であるなら<code>then</code>キーワードを用いる必要があります。そうすることでCoffeeScriptはいつブロックが始まるか理解できます。条件演算子(<code>?:</code>)はサポートされていません。そのかわりに1行で<code>if/else</code>文を用いなければいけません。</p>

<p>CoffeeScriptはまたRubyの慣用句である後置<code>if</code>文を利用可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>alert "It's cold!" if heat &lt; 5
</code></pre>

<p>否定にびっくりマーク(<code>!</code>)を用いる代わりに、<code>not</code>キーワードを用いることが可能です。それを用いることでコードをより読み易くすることが可能です。びっくりマークは簡単に見落としますから。</p>

<p><span class="csscript"></span></p>

<pre><code>if not true then "Panic"
</code></pre>

<p>上の例ではCoffeeScriptの<code>unless</code>文を<code>if</code>の反対として使用可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>unless true
  "Panic"
</code></pre>

<p><code>not</code>と似た感覚で、CoffeeScriptは<code>is</code>文も持っています。<code>===</code>に変換されます。</p>

<p><span class="csscript"></span></p>

<pre><code>if true is 1
  "Type coercion fail!"
</code></pre>

<p><code>is not</code>の代わりに、<code>isnt</code>を使用可能です。</p>

<pre><code>if true isnt true
  alert "Opposite day!"
</code></pre>

<p>You may have noticed in the examples above, that CoffeeScript is converting <code>==</code> operators into <code>===</code> and <code>!=</code> into <code>!==</code>. This is one of my favorite features to the language, and yet one of the most simple. What's the reasoning behind this? Well frankly JavaScript's type coercion is a bit odd, and its equality operator coerces types in order to compare them, leading to some confusing behaviors and the source of many bugs. There's a longer discussing on this topic in chapter 7.
上の例でお気付きでしょうが、CoffeeScriptは<code>==</code>演算子を<code>===</code>に変換し、<code>!=</code>を<code>!==</code>に変換します。これはこの言語の私の好きな最もシンプルな機能の1つです。この考えの背景にあるものは何でしょうか？率直に言ってJavaScriptの型変換は少し変です。そしてそれらの比較演算子は比較のために型変換を強制します。そのことが理解し難い挙動に繋り、ひいては多くのバグの元となります。このトピックについては第7章でより長い議論を行います。</p>

<h2>文字列への挿入</h2>

<p>CoffeeScriptはRuby式の文字列への挿入をJavaScriptに対し追加しています。ダブルクォートで括った文字列に対しては<code>#{}</code>タグを含むことができます。その中に文字列に対して挿入される式を記述します。</p>

<p><span class="csscript"></span></p>

<pre><code>favourite_color = "Blue. No, yel..."
question = "Bridgekeeper: What... is your favourite color?
            Galahad: #{favourite_color}
            Bridgekeeper: Wrong!
            "
</code></pre>

<p>上の例を見てわかります通り、複数行に渡る文字列もまた可能です。各行に<code>+</code>を置く必要はありません。</p>

<h2>ループと内包表記</h2>

<p>JavaScriptの配列の繰り返しはとても古風な文法でした。C言語のようなより古い言語を思い出させ、現在のオブジェクト指向言語とは異なります。ES5の<code>forEach()</code>の登場により状況はいくらか改善されました。しかしそれでも毎回関数呼出を必要とし、そのために遅いものとなっています。再びCoffeeScriptが美しい文法でその助けとなります。</p>

<p><span class="csscript"></span></p>

<pre><code>for name in ["Roger", "Roderick", "Brian"]
  alert "Release #{name}"
</code></pre>

<p>もし繰り返しのインデックスが必要なら、もう1つの引数を渡すだけです。</p>

<p><span class="csscript"></span></p>

<pre><code>for name, i in ["Roger the pickpocket", "Roderick the robber"]
  alert "#{i} - Release #{name}"
</code></pre>

<p>後置形式を用いることで1行で繰返すことも可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>release prisoner for prisoner in ["Roger", "Roderick", "Brian"]
</code></pre>

<p>Pythonの内包表記のように、フィルタリングを行うことも可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>prisoners = ["Roger", "Roderick", "Brian"]
release prisoner for prisoner in prisoners when prisoner[0] is "R" 
</code></pre>

<p>内包表記を用いてオブジェクトのプロパティについて繰り返しを行うことも可能です。<code>in</code>キーワードの代わりに<code>of</code>を使用して下さい。</p>

<p><span class="csscript"></span></p>

<pre><code>names = sam: seaborn, donna: moss
alert("#{first} #{last}") for first, last of names
</code></pre>

<p>CoffeeScriptが持つローレベルなループは<code>while</code>のみです。JavaScriptの<code>while</code>と同じような動作をします。しかし追加の利点として結果の配列を返します。つまり<code>Array.prototype.map()</code>関数と同じようにです。</p>

<p><span class="csscript"></span></p>

<pre><code>num = 6
minstrel = while num -= 1
  num + " Brave Sir Robin ran away"
</code></pre>

<h2>配列</h2>

<p>CoffeeScriptは配列の範囲(region)を用いたスライスについてRubyからヒントを得ています。範囲は2つの数値から作られます。最初と最後の位置を示す2つの数値は<code>..</code>か<code>...</code>で区切られます。もし範囲の前に何も無い場合にはCoffeeScriptはそれを配列に変換します。</p>

<p><span class="csscript"></span></p>

<pre><code>range = [1..5]
</code></pre>

<p>しかし、もし範囲が変数の直後に置かれたならCoffeeScriptはそれを<code>slice()</code>メソッドの呼出に変換します。</p>

<p><span class="csscript"></span></p>

<pre><code>firstTwo = ["one", "two", "three"][0..1]
</code></pre>

<p>上の例では範囲は新しい配列を返します。元の配列の最初の2つの要素のみを持つ配列です。同じ文法を配列の一部を他の配列で置換することにも使えます。</p>

<p><span class="csscript"></span></p>

<pre><code>numbers = [0..9]
numbers[3..5] = [-3, -4, -5]
</code></pre>

<p>便利なのはJavaScriptでは<code>slice()</code>を文字列に対しても呼ぶことが可能なことです。そのため範囲を文字列に対して使用することで部分文字列を返すことが可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>my = "my string"[0..2]
</code></pre>

<p>JavaScriptでは配列の中に値が存在するか確認することはとても面倒でした。特に<code>indexOf()</code>が全てのブラウザ間においてサポートされている訳ではなかったからです。(IE、君のことを言っているんだよ)。CoffeeScripitはこれを<code>in</code>演算子で解決します。次の例をご覧下さい。</p>

<p><span class="csscript"></span></p>

<pre><code>words = ["rattled", "roudy", "rebbles", "ranks"]
alert "Stop wagging me" if "ranks" in words 
</code></pre>

<h2>エイリアス(別名)と存在確認演算子</h2>

<p>CoffeeScriptはいくつかの便利なエイリアスをタイピングの量を減らすために利用できます。そのうちの1つは<code>@</code>です。これは<code>this</code>のエイリアスです。</p>

<p><span class="csscript"></span></p>

<pre><code>@saviour = true
</code></pre>

<p>もう1つは<code>::</code>です。これは<code>prototype</code>の別名です。</p>

<p><span class="csscript"></span></p>

<pre><code>User::first = -&gt; @records[0]
</code></pre>

<p>JavaScriptでは<code>if</code>を<code>null</code>チェックに用いることは普通です。しかし空文字列と0が共に<code>false</code>に変換されることが落とし穴として存在し、あなたを陥れます。CoffeeScriptの存在確認演算子である<code>?</code>は変数が<code>null</code>でないか、<code>undefined</code>でなければtrueを返します。Rubyの<code>nil?</code>と同様です。</p>

<p><span class="csscript"></span></p>

<pre><code>praise if brian?
</code></pre>

<p>これは<code>||</code>演算子の代わりにも使えます。</p>

<p><span class="csscript"></span></p>

<pre><code>velocity = southern ? 40
</code></pre>

<p>もし<code>null</code>チェックをプロパティにアクセスする前に行う場合、存在確認演算子をその前に置くだけでスキップすることが可能です。これはActive Supportの<a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try"><code>try</code></a>メソッドに似ています。</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs()?.kick()
</code></pre>

<p>同様に、プロパティが実際に関数であり呼出可能かチェックすることが括弧の直前に存在確認演算子を置くことで可能です。もしプロパティが存在しないか、関数ではない場合、呼出は行われません。</p>

<p><span class="csscript"></span></p>

<pre><code>blackKnight.getLegs().kick?()
</code></pre>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Classes</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>クラス</h1>

<p>JavaScriptのクラスは純粋主義者にとってニンニクがドラキュラに対して与えるものと同様な影響を持っていました。とはいえ、正直に言ってあなたがそのような傾倒をお持ちでしたらCoffeeScriptの本を呼んだりはしないでしょう。しかし、クラスは他の言語と同じようにJavaScriptでもとても便利であると判明しました。そしてCoffeeScriptは素晴しい抽象化を提供します。</p>

<p>その裏では、CoffeeScriptはJavaScriptのネイティブなprototypeをクラスを作成するのに用いています。少しの構文糖を静的なプロパティの継承とコンテキストの永続化のために用いています。開発者としてのあなたに見えるのは<code>class</code>キーワードだけです。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
</code></pre>

<p>この上の例では<code>Animal</code>がクラス名であり、かつ結果としてインスタンスの作成に用いる変数です。裏側ではCoffeeScriptはコンストラクタ関数を用いており、クラスのインスタンスを<code>new</code>演算子を用いて作成することが可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal
</code></pre>

<p>コンストラクタ(インスタンス化において実行される関数)を定義することは簡単です。<code>constructor</code>という名前の関数を使用してください。これはRubyの<code>initialize</code>やPythonの<code>__init__</code>と同様です。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (name) -&gt;
    @name = name
</code></pre>

<p>実はCoffeeScriptはインスタンスのプロパティ設定の一般的なパターンのために速記法を用意しています。引数の直前に<code>@</code>を置くことで、CoffeeScriptはコンストラクタの中では自動的に引数をインスタンスのプロパティに設定します。実際にはこの速記法はクラスの外の通常の関数でも使用可能です。下の例は先程の例と等価です。先程はインスタンスのプロパティを手で設定しています。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;
</code></pre>

<p>期待どおりに、インスタンス化において渡される任意数の引数はコンストラクタ関数に渡されます。</p>

<p><span class="csscript"></span></p>

<pre><code>animal = new Animal("Parrot")
alert "Animal is a #{animal.name}"
</code></pre>

<h2>インスタンスプロパティ</h2>

<p>クラスにインスタンスプロパティを追加することはとても簡単です。オブジェクトにプロパティを追加する文法そのものです。ただプロパティがクラスの本体で正しくインデントされているかは注意してください。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: (customer) -&gt;

animal = new Animal
animal.sell(new Customer)
</code></pre>

<p>JavaScriptにおけるコンテキストの変更は嫌なものです。以前の文法の章でCoffeeScriptがファットアロー<code>=&gt;</code>を用いることで<code>this</code>の値を特有のコンテキストにロックするかを説明しました。関数がどのようなコンテキストの下に呼ばれようとも、関数が作成されたコンテキストの下で実行されます。つまりファットアローをインスタンスメソッドに用いることで、それが正しいコンテキストで実行されることを確認することができます。<code>this</code>は常に現在のインスタンスになります。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  price: 5

  sell: =&gt;
    alert "#{@price}シリングになります!"

animal = new Animal
$("#sell").click(animal.sell)
</code></pre>

<p>上の例でデモしたとおり、これはイベントコールバックにおいてとても便利です。通常は<code>sell()</code>関数は<code>#sell</code>要素の下で実行されます。しかし<code>sell()</code>に対しファットアローを用いることで正しいコンテキストが管理されていることを確認できます。<code>this.price</code>は<code>5</code>に等しくなります。</p>

<h2>静的なプロパティ</h2>

<p>クラスの(つまり静的な)プロパティはどうやって定義するのでしょうか？実はクラス定義の中では<code>this</code>はクラスオブジェクトを指しています。つまりクラスプロパティは<code>this</code>の上に直接設定することになります。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  this.find = (name) -&gt;      

Animal.find("Parrot")
</code></pre>

<p>実際には、あなたも覚えておいででしょうが、CoffeeScriptには<code>this</code>を<code>@</code>で記述可能で、静的プロパティをより簡潔に記述可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  @find: (name) -&gt;

Animal.find("Parrot")
</code></pre>

<h2>継承とsuper</h2>

<p>何らかの形の継承が無ければ正しいクラスの実装にはならないでしょう。CoffeeScriptは失望させません。<code>extends</code>キーワードを用いて他のクラスを継承することが可能です。下の例では<code>Parrot</code>は<code>Animal</code>を拡張し、全てのインスタンスプロパティ、<code>alive()</code>等を継承しています。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

  alive: -&gt;
    false

class Parrot extends Animal
  constructor: -&gt;
    super("Parrot")

  dead: -&gt;
    not @alive()
</code></pre>

<p>上の例でお気付きになられるでしょうが、ここでは<code>super()</code>キーワードを使いました。裏側ではクラスの親のprototypeの関数呼出に翻訳され、現在のコンテキストにて実行されます。この例では<code>Parrot.__super__.constructor.call(this, "Parrot");</code>になります。実際にこれはRubyやPythonで<code>super</code>を実行したのと同じ影響を持ち、オーバーライドされた関数を実行します。</p>

<p><code>constructor</code>をオーバーライドしない限り、デフォルトではCoffeeScriptは親のコンストラクタをインスタンスが作成された時に実行します。</p>

<p>CoffeeScriptはprotype形式の継承を用いて、自動的にクラスの全てのインスタンスプロパティを継承します。これはクラスが動的であることを示します。子が作成された後に親クラスにインスタンスプロパティを追加すればそのプロパティは全ての継承した子に伝播します。</p>

<p><span class="csscript"></span></p>

<pre><code>class Animal
  constructor: (@name) -&gt;

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
</code></pre>

<p>しかし静的なプロパティはサブクラスにコピーされるのであり、インスタンスプロパティのようにプロトタイプを用いて継承されるのではないことは重要です。これはJavaScriptのプロトタイプアーキテクチャの実装の詳細によります。そして次善の策を探すのは難しい問題です。</p>

<h2>ミックスイン</h2>

<p>ミックスイン<a href="http://en.wikipedia.org/wiki/Mixin">Mixins</a>はCoffeeScriptの言語仕様としてサポートされたものではありません。しかし簡単に実装可能です。例として、2つの関数を考えます。<code>extend()</code>と<code>include()</code>はあるクラスにクラスとインスタンスのプロパティを別々に追加します。</p>

<p><span class="csscript"></span></p>

<pre><code>extend = (obj, mixin) -&gt;
  obj[name] = method for name, method of mixin        
  obj

include = (klass, mixin) -&gt;
  extend klass.prototype, mixin

# Usage
include Parrot,
  isDeceased: true

(new Parrot).isDeceased
</code></pre>

<p>ミックスインは継承が適切でない場合にモジュール間で共通なロジックを共有するのにとても良いパターンです。ミックスインの利点は継承が1つのクラスからしか継承できないのに対し、複数を取り込めることです。</p>

<h2>クラスの拡張</h2>

<p>ミックスインはとても格好良いです。しかしあまりオブジェクト指向ではありません。代わりとしてCoffeeScriptのクラスにミックスインを統合しましょう。<code>Module</code>と呼ばれるクラスを定義してミックスインサポートのために継承できるようにしましょう。<code>Module</code>は2つの静的関数を持ちます。<code>@extend()</code>と<code>@include()</code>で静的プロパティとインスタンスプロパティを個別に拡張するのに利用可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>moduleKeywords = ['extended', 'included']

class Module
  @extend: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      @[key] = value

    obj.extended?.apply(@)
    this

  @include: (obj) -&gt;
    for key, value of obj when key not in moduleKeywords
      # Assign properties to the prototype
      @::[key] = value

    obj.included?.apply(@)
    this
</code></pre>

<p><code>moduleKeywords</code>変数まわりのちょっとしたダンスはミックスインがクラスを拡張した時にコールバックをサポートするためです。我々の<code>Module</code>クラスがどう動くか見てみましょう。</p>

<p><span class="csscript"></span></p>

<pre><code>classProperties = 
  find: (id) -&gt;
  create: (attrs) -&gt;

instanceProperties =
  save: -&gt; 

class User extends Module
  @extend classProperties
  @include instanceProperties

# Usage:
user = User.find(1)

user = new User
user.save()
</code></pre>

<p>ご覧のとおり、我々は静的プロパティとして<code>find()</code>と<code>create()</code>を<code>User</code>クラスに追加しました。またインスタンスプロパティも<code>save()</code>を追加しました。
モジュールが拡張されたときにはコールバックを得ますので静的、及びインスタンスプロパティを適用するプロセスはショートカット可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>ORM = 
  find: (id) -&gt;
  create: (attrs) -&gt;
  extended: -&gt;
    @include
      save: -&gt; 

class User extends Module
  @extend ORM
</code></pre>

<p>とてもシンプルでエレガントでしょう！</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Idioms</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>CoffeeScriptに共通なイディオム</h1>

<p>各言語には慣用句や慣習があります。CoffeeScriptも例外ではありません。この章ではそれらの規約を説明し、JavaScriptとCoffeeScriptの比較をいくつかご紹介することでこの言語の実践的なセンスを得て頂きます。</p>

<h2>Each</h2>

<p>JavaScriptでは配列の全てのアイテムに対し繰返しを行う場合、新しく追加された<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/foreach"><code>forEach()</code></a>関数を用いるか、古いC言語のスタイルである<code>for</code>ループを用いることができました。もしECMAScript 5で紹介されたJavaScriptの最新の機能を用いる計画でしたら、私は古いブラウザもサポートするために<a href="https://github.com/kriskowal/es5-shim">shim</a>をページに入れておくことをお勧めします。</p>

<pre><code>for (var i=0; i &lt; array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
</code></pre>

<p><code>forEach()</code>の文法は簡潔で読み易いものですが、配列の個々の繰り返しにおいてコールバック関数が実行されるための不利益を被ります。つまり同等な<code>for</code>ループに比べると遅くなります。CoffeeScriptではどうなるか見てみましょう。</p>

<p><span class="csscript"></span></p>

<pre><code>myFunction(item) for item in array
</code></pre>

<p>読み易く簡潔な文法です。あなたも同意されることを疑いません。そしてこれの良いところは裏側では<code>for</code>ループにコンパイルされることです。つまりCoffeeScriptの文法は<code>forEach()</code>と同じ表現力を持ちながら、パフォーマンスやshimの必要性といった警告がありません。</p>

<h2>Map</h2>

<p><code>forEach()</code>と同じように、ES5は自然なmap関数も持っています。以前の<code>for</code>ループに比べより簡潔な文法を持っています。すなわち<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>です。残念なことにこれも<code>forEach()</code>と同じ警告を受けています。実行速度が関数呼出のために大きく劣っているのです。</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
</code></pre>

<p>文法の章で説明したとおり、CoffeeScriptの内包表記は<code>map()</code>と同じ処理を行うことが可能です。内包表記を括弧で囲んでいることに注意して下さい。それはあなたが期待したmapを実行した結果配列を得ることを確実にするのに<strong>とても重要</strong>です。</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item.name for item in array)
</code></pre>

<h2>選択</h2>

<p>同様に、ES5は配列を縮約するのに便利な関数、<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/filter"><code>filter()</code></a>を持っています。</p>

<pre><code>var result = []
for (var i=0; i &lt; array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
</code></pre>

<p>CoffeeScriptの基本的文法は<code>when</code>キーワードをアイテムを比較しながらフィルタリングするのに用います。裏側では<code>for</code>ループが生成されています。実行の全体は無名関数の中で行なわれ、スコープが漏れることや変数名の衝突を防ぎます。</p>

<p><span class="csscript"></span></p>

<pre><code>result = (item for item in array when item.name is "test")
</code></pre>

<p>括弧を絶対に忘れないで下さい。でなければ<code>result</code>は配列の最後の要素になるでしょう。
CoffeeScriptの内包表記はとても自由度が高く次の例のようにとても強力な選択を行うことを可能にします。</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
(if score &gt; 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# または
passed = (score for score in scores when score &gt; 60)
</code></pre>

<p>もし内包表記が長すぎる場合には複数行に分けることが可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score &gt; 60 then passed else failed).push score
</code></pre>

<h2>含む</h2>

<p>配列の中に値が存在するかを確認するには通常は<code>indexOf()</code>を用います。しかしInternet Explorerがそれを実装していないがために、うんざりすることですが今でも代替法が必要です。</p>

<pre><code>var included = (array.indexOf("test") != -1)
</code></pre>

<p>CoffeeScriptはPythonプログラマなら気付くであろうこれに対する素敵な代替法を持っています。つまり<code>in</code>です。</p>

<p><span class="csscript"></span></p>

<pre><code>included = "test" in array
</code></pre>

<p>裏側ではCoffeeScriptは配列の中に値があるかを確認するのに<code>Array.prototype.indexOf()</code>を使用しています。そしてもし必要ならその代替を利用しています。残念なことですがこれは同じ<code>in</code>という文法が文字列に対しては動作しないことを意味します。<code>indexOf()</code>を使う方法に戻って、結果が<code>-1</code>でないか確認します。</p>

<p><span class="csscript"></span></p>

<pre><code>included = "a long test string".indexOf("test") isnt -1
</code></pre>

<p>またはより良い方法として、ビット演算をハイジャックして<code>-1</code>との比較をしなくてもすむようにします
<span class="csscript"></span></p>

<pre><code>string   = "a long test string"
included = !!~ string.indexOf "test"
</code></pre>

<h2>プロパティの繰り返し</h2>

<p>JavaScriptでプロパティの塊について繰返す場合には<code>in</code>演算子を用いました。次の例をご覧下さい。</p>

<pre><code>var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
</code></pre>

<p>しかし、前のセクションで見たとおり、CoffeeScriptは既に<code>in</code>を配列に用いるのに予約済みです。その代わりに、演算子は<code>of</code>と名前を変えこのように使えます。</p>

<p><span class="csscript"></span></p>

<pre><code>object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
</code></pre>

<p>ご覧のように、プロパティの名前とその値の両方に変数を指定可能です。より便利になりました。</p>

<h2>最小/最大</h2>

<p>このテクニックはCoffeeScript特有のものではありません。しかし便利なのでとにかく紹介してみましょう。<code>Math.max</code>と<code>Math.min</code>は複数の引数を取ります。そのため<code>...</code>を用いることで配列を渡し、配列の中の最大値と最小値を得ることができます。</p>

<p><span class="csscript"></span></p>

<pre><code>Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
</code></pre>

<p>このトリックが本当に大きな配列では失敗してしまうのは仕方がありません。ブラウザは関数に渡せる引数の数に制限があります。</p>

<h2>複数の引数</h2>

<p>上の<code>Math.max</code>の例では<code>...</code>を使い配列を解体し複数の引数として<code>max</code>に渡しました。裏側ではCoffeeScriptは関数呼出を<code>apply()</code>を使うように変換し、配列が複数の引数として<code>max</code>に渡るようにしています。この機能を他にも使うことが可能です。例えば関数呼出を委任(proxy)するには次のようにします。</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  log: -&gt;
    console?.log(arguments...)
</code></pre>

<p>または引数をパスする前に変えてしまうことも可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>Log =
  logPrefix: "(App)"

  log: (args...) -&gt;
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
</code></pre>

<p>しかし次のことは心に留めておいてください。CoffeeScriptは自動的に関数の実行コンテキストをその関数が実行されるオブジェクトに設定します。上の例では<code>console</code>になるでしょう。もし指定したコンテキストを設定したい場合には<code>apply()</code>を手動で呼ばなければなりません。</p>

<h2>And/or</h2>

<p>CoffeeScriptスタイルガイドは<code>or</code>は<code>||</code>より好ましく、<code>and</code>は<code>&amp;&amp;</code>より好ましいと指示しています。私はそれが何故だかわかります。前者のほうがより読み易いといったところです。それでもなお2つのスタイルは同じ結果をもたらします。</p>

<p>このより英語らしいスタイルという優先度は<code>==</code>の代わりに<code>is</code>、<code>!=</code>の代わりに<code>isnt</code>ということにも当て嵌ります。</p>

<p><span class="csscript"></span></p>

<pre><code>string = "migrating coconuts"
string == string # true
string is string # true
</code></pre>

<p>CoffeeScriptへのとても嬉しい拡張の1つは<code>or equals</code>です。これはRuby使いなら<code>||=</code>と認識するでしょう。</p>

<p><span class="csscript"></span></p>

<pre><code>hash or= {}
</code></pre>

<p>もしhashが<code>false</code>と評価されるならそれには空のオブジェクトが代入されます。ここで重要なのはこの式は<code>0</code>、<code>""</code>、<code>null</code>もまたfalseと判定することです。もしそれがあなたの意図することでなければCoffeeScriptの存在確認演算子を用いるべきでしょう。そちらは<code>hash</code>が<code>undefined</code>であるか<code>null</code>である場合のみ作動します。</p>

<p><span class="csscript"></span></p>

<pre><code>hash ?= {}
</code></pre>

<h2>割当の解体</h2>

<p>割当の解体は任意の深さの配列とオブジェクトのネストに用いられ、奥にネストされたプロパティを取り出すのを手助けします。</p>

<p><span class="csscript"></span></p>

<pre><code>someObject = { a: 'value for a', b: 'value for b' }
{ a, b } = someObject
console.log "a is '#{a}', b is '#{b}'"
</code></pre>

<p>これはNodeのアプリケーションにおいてモジュールを必要とする場合に特に有効です。</p>

<p><span class="csscript"></span></p>

<pre><code>{join, resolve} = require('path')

join('/Users', 'Alex')
</code></pre>

<h2>外部ライブラリ</h2>

<p>外部ライブラリを利用することはCoffeeScriptのライブラリの関数を呼ぶのと全く同じです。なぜなら全ては最後にはJavaScriptへとコンパイルされるからです。CoffeeScriptと<a href="http://jquery.com">jQuery</a>を同時に利用するのは特にエレガントです。jQueryのAPIには大量のコールバックがあるからです。</p>

<p><span class="csscript"></span></p>

<pre><code># ローカルの別名を使う
$ = jQuery

$ -&gt;
  # DOMコンテンツのロード終了後
  $(".el").click -&gt;
    alert("Clicked!")
</code></pre>

<p>全てのCoffeeScriptの出力は無名関数にてラップされるため、ローカルの<code>$</code>を<code>jQuery</code>のエイリアスとして設定可能です。これによりjQueryの衝突回避モードが許可されていて<code>$</code>が再定義されていても私達のスクリプトは望んだとおりに機能することを確実にします。</p>

<h2>プライベート変数</h2>

<p>CoffeeScriptの<code>do</code>キーワードは関数を直ぐに実行しますが、スコープをカプセル化し、変数を守るのに最高の方法です。下の例では、<code>classToType</code>という変数を無名関数のコンテキストで定義し、<code>do</code>により直ぐに実行しています。その無名関数は2つ目の無名関数を返します。</p>

<p><span class="csscript"></span></p>

<pre><code># 関数をすぐに実行する
type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  # 関数を返す
  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"
</code></pre>

<p>つまり、<code>classToType</code>は完全にプライベートで実行中の無名関数の外側からは二度と参照することはできません。このパターンはスコープをカプセル化し、変数を隠すのに最適です。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Compiling</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>自動的にCoffeeScriptをコンパイルする</h1>

<p>CoffeeScriptの問題はあなたとJavaScriptの間に他のレイヤーを増やすことです。CoffeeScriptのファイルが変更され、古くなる度に手動でコンパイルせねばなりません。幸いなことにCoffeeScriptはいくつかのコンパイル代替形態を持っており、開発サイクルをいくらかスムーズにすることが可能です。</p>

<p>最初の章で説明したとおり、CoffeeScriptは<code>coffee</code>コマンドを用いてコンパイル可能です。</p>

<pre><code>coffee --compile --output lib src
</code></pre>

<p>上の例では全ての<code>src</code>ディレクトリ内の<code>.coffee</code>ファイルはコンパイルされ、<code>lib</code>ディレクトリに個々の出力が置かれます。これを呼ぶだけでもちょっと面倒かもしれません。自動化する方法を探しましょう。</p>

<h2>Cake</h2>

<p><a href="http://jashkenas.github.com/coffee-script/#cake">Cake</a>はとてもシンプルなビルドシステムで<a href="http://www.gnu.org/software/make/">Make</a> や <a href="http://rake.rubyforge.org/">Rake</a>に倣っています。このライブラリは<code>coffee-script</code>のnpmパッケージにバンドルされており<code>cake</code>という名前のコマンドで利用可能です。</p>

<p><code>Cakefile</code>と呼ばれるファイルにCoffeeScriptを用いることでタスクを定義できます。<code>cake [task] [options]</code>を同じディレクトリで実行することにより、Cakeがそれらのタスクを取り上げ、実行さうぇることが可能です。全てのタスクとオプションのリストを表示するにはただ<code>cake</code>と入力します。</p>

<p>タスクは<code>task()</code>関数を用いて定義します。名前と任意で詳細説明とコールバック関数を与えます。例として<code>Cakefile</code>という名のファイルを作り、<code>lib</code>と<code>src</code>という2つのディレクトリを作成してください。<code>Cakefile</code>には次の内容を追加します。</p>

<p><span class="csscript"></span></p>

<pre><code>fs = require 'fs'

{print} = require 'sys'
{spawn} = require 'child_process'

build = (callback) -&gt;
  coffee = spawn 'coffee', ['-c', '-o', 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
  coffee.on 'exit', (code) -&gt;
    callback?() if code is 0

task 'build', 'Build lib/ from src/', -&gt;
  build()
</code></pre>

<p>上の例では<code>build</code>というタスクを定義しました。<code>cake build</code>で実行できます。これは先の例と同じコマンドを実行し<code>src</code>にあるCoffeeScriptファイルを全てJavaScriptにコンパイルし、<code>lib</code>に置きます。これでHTMLファイルから通常どおりに<code>lib</code>の中にあるJavaScriptファイルを参照できます。</p>

<p><span class="csscript"></span></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=utf-8&gt;
&lt;script src="lib/app.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;      
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>これではまだ<code>cake build</code>をCoffeeScriptのコードを変更するたびに手動で実行せねばなりません。理想からは遠いです。幸運なことに、<code>coffee</code>コマンドは別のオプションがあります。<code>--watch</code>はコマンドにディレクトリに対して変更を見張るように指示し、必要な場合にはリコンパイルします。それを用いて別のタスクを定義しましょう。</p>

<p><span class="csscript"></span></p>

<pre><code> task 'watch', 'Watch src/ for changes', -&gt;
    coffee = spawn 'coffee', ['-w', '-c', '-o', 'lib', 'src']
    coffee.stderr.on 'data', (data) -&gt;
      process.stderr.write data.toString()
    coffee.stdout.on 'data', (data) -&gt;
      print data.toString()
</code></pre>

<p>もしあるタスクが別のタスクに依存する場合、別のタスクを<code>invoke(name)</code>を用いて実行すらことが可能です。<code>Cakefile</code>にもう一つ便利なタスクを追加しましょう。<code>index.html</code>を開きソースの変更の見張りを開始します。</p>

<p><span class="csscript"></span></p>

<pre><code>task 'open', 'Open index.html', -&gt;
  # 最初に開いて、次に見張る
  spawn 'open', 'index.html'
  invoke 'watch'
</code></pre>

<p>タスクには<code>option()</code>関数を用いてオプションを定義することが可能です。引数として短かい名前、長い名前、そして説明を渡せます。</p>

<p><span class="csscript"></span></p>

<pre><code>option '-o', '--output [DIR]', 'output dir'

task 'build', 'Build lib/ from src/', -&gt;
  # Now we have access to a `options` object
  coffee = spawn 'coffee', ['-c', '-o', options.output or 'lib', 'src']
  coffee.stderr.on 'data', (data) -&gt;
    process.stderr.write data.toString()
  coffee.stdout.on 'data', (data) -&gt;
    print data.toString()
</code></pre>

<p>As you can see, the task context now has access to an <code>options</code> object containing any data specified by the user. If we run <code>cake</code> without any other arguments, all the tasks and options will be listed.
ご覧のとおり、タスクコンテキストがユーザが指定した任意のデータを持つ<code>options</code>オブジェクトにアクセス可能となりました。もし<code>cake</code>を引数無しで実行した場合、全てのタスクと引数がリストされます。</p>

<p>Cake's a great way of automating common tasks such as compiling CoffeeScript without going to the hassle of using bash or Makefiles. It's also worth taking a look at <a href="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cake's source</a>, a great example of CoffeeScript's expressiveness and beautifully documented alongside the code comments.
Cakeは、bashやMakeファイルを用いずにCoffeeScriptをコンパイルするような一般的なタスクを自動化する、素晴しい方法です。<a href="http://jashkenas.github.com/coffee-script/documentation/docs/cake.html">Cakeのソース</a>を読むことにはとても価値があります。CoffeeScriptの表現力の素晴しい例です。コードにはコメントが添えられて美しくドキュメント化されています。</p>

<h2>サーバサイドサポート</h2>

<p>CakeをCoffeeScriptのコンパイルに用いるのは静的なサイトでは問題ありません。しかし動的なサイトではCoffeeScriptのコンパイルをリクエスト/レスポンスサイクルに統合せねばなりません。色々な統合ソリューションが人気の高いバックエンドの言語とフレームワークに対して既に存在します。例えば<a href="http://rubyonrails.org/">Rails</a> や <a href="https://www.djangoproject.com/">Django</a>です。</p>

<p>Rails3.1ではCoffeeScriptのサポートは<a href="https://github.com/sstephenson/sprockets">Sprockets &amp; the asset pipeline</a>を通して提供されます。CoffeeScriptファイルを<code>app/assets/javascripts</code>の下に追いてください。Railsは十分に賢くリクエストを受けたときに事前にコンパイルします。JavaScriptとCoffeeScriptのファイルは特別なコメントの指示を用いて包まれ、連結されます。これは1つのリクエストでアプリケーションの全てのJavaScriptを取得することが可能であることを意味します。運用時にはRailsはコンパイル結果をディスクに記録し、キャッシュされ、高速なサービスを保障します。</p>

<p>他のRubyの選択肢には<a href="http://rack.github.com/">rack</a>サーバがあります。例えば37signalの<a href="http://pow.cx/">Pow</a> や Joshua Peek の <a href="http://josh.github.com/nack/">Nack</a>があります。両者共、もしあなたのアプリケーションがRailsの他の機能や関連するオーバーヘッドを必要としないのなら最高にお勧めです。</p>

<p>Djangoもまた<a href="http://pypi.python.org/pypi/django-coffeescript/">CoffeeScriptのサポート</a>を特別なテンプレートタグを通して行います。インラインコードでも外部ファイルでも利用可能です。</p>

<p>RubyとPythonは共にCoffeeScriptをコンパイルする時、NodeやCoffeeScriptのライブラリへパイプから出力します。そのためそれらを開発の間にインストールしなければなりません。もしNodeを直接、あなたのサイトのバックエンドとして使用している場合、CoffeeScriptの統合はよりシンプルで、バックエンドとフロントエンドコードの両方で使用可能です。このことについては次の章でより詳しく説明します。<a href="https://github.com/sstephenson/stitch">Stitch</a>を用いて全てのクライアントサイドCoffeeScriptを提供します。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - Applications</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>アプリケーションを作成する</h1>

<p>ここまでで文法の概要について学びました。ここからは実際にCoffeeScriptアプリケーションを構築しましょう。この章の狙いは初心者や熟練の技術者に限らず、全てのCoffeeScript開発者にとって有益なものになることです。本当に、JavaScriptの開発者にとっても適切なものとなるはずです。</p>

<p>幾つかの原因により、開発者がクライアントサイドJavaScriptアプリケーションを構築する時、パターンと規約を試し、テストはするもののそれらはしばしば窓から飛んでいってしまい、最終的な結果はひどいスパゲッティで、保守不可能にこんがらがったJavaScriptになります。私は常にアプリケーションアーキテクチャがどれだけ重要かを強調しています。もしあなたがJavaScript/CoffeeScriptを単純なフォームの妥当性確認を越えて用いるのであれば、<a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>のようなアプリケーション構造を実装するべきです。</p>

<p>保守可能な巨大アプリケーションを実装するための秘密は巨大なアプリケーションを作らないことです。つまり言い換えれば、一連のモジュールとして分割されたコンポーネントを作るのです。アプリケーションロジックは出来る限り一般的にし、適切に抽象化します。最後にロジックを分割し、ビュー、モデル、コントローラ(MVC)に分けます。MVCの実装はこの章の範囲を越えています。MVCについては私の本、<a href="http://oreilly.com/catalog/9781449307530/">JavaScript Web Applications</a>をチェックして、<a href="http://documentcloud.github.com/backbone/">Backbone</a> や <a href="https://github.com/maccman/spine">Spine</a>のようなフレームワークを利用して下さい。ここではそうではなくCommonJSモジュールを用いてアプリケーションの構造化を説明します。</p>

<h2>構造とCommonJS</h2>

<p>さて、CommonJSモジュールとは一体何でしょうか？もしあなたが<a href="http://nodejs.org/">NodeJS</a>を以前に使ったことがあるのなら、あなたはCommonJSを恐らく気付かずに使ったことがあります。CommonJSモジュールは最初にサーバサイドJavaScriptライブラリを書くために開発されました。ローディング時間や名前空間、スコープの問題に向き合うためにです。CommonJSは全てのJavaScript実装の間で互換性を保持するようにするための共通フォーマットでした。その狙いは<a href="http://www.mozilla.org/rhino/">Rhino</a>向けのライブラリがnodeでも動くことでした。やがてこのアイデアはブラウザに向けられました。そして今私達は<a href="http://requirejs.org">RequireJS</a> や <a href="https://github.com/jbrantly/yabble">Yabble</a>のような素晴しいライブラリをクライアントサイドでモジュールを用いるために持っている訳です。</p>

<p>実際に、モジュールはあなたのコードがローカルネームスペース(コードカプセル化)の中で動くことを保障します。他のモジュールを<code>require()</code>関数で読むことができます。そして<code>module.exports</code>を通してモジュールプロパティを外部に公開することができます。それではそのことについてもう少し掘り下げてみましょう。</p>

<h3>ファイルを要求(require)する</h3>

<p>他のモジュールやライブラリ内で<code>require()</code>を用いてロードすることが可能です。単純にモジュールの名前を渡すだけです。もしロードパスの中に存在すれば、そのモジュールを表すオブジェクトを返します。次の例をご覧下さい。</p>

<pre><code>User = require("models/user")
</code></pre>

<p>同期的なrequireのサポートは議論の余地のある問題です。しかし多くは主流のローダーライブラリと最新のCommonJSの<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">提案</a>により解決されています。もしあなたが私の支持する以下のStichとの道とは別の道を選択することを決められたのであれば、それがあなたが良く理解しなければならないものとなるでしょう。</p>

<h3>プロパティを外部に公開する</h3>

<p>デフォルトでは、モジュールはプロパティを1つも公開しません。中身は<code>require()</code>の呼出に対し、完全に不可視です。もしあるプロパティがあなたのモジュールからアクセス可能であって欲しいと思った場合、<code>module.exports</code>を用いて設定する必要があります。</p>

<pre><code># random_module.js
module.exports.myFineProperty = -&gt;
  # 何か
</code></pre>

<p>これでこのモジュールがrequireされる度に<code>myFineProperty</code>は公開されます。</p>

<pre><code>myFineProperty = require("random_module").myFineProperty
</code></pre>

<h2>Stitch: 縫い上げよう</h2>

<p>あなたのコードをCommonJSモジュールとして形式化することは全く問題がありません。しかし実際にどうやってこれをクライアントで実行するのでしょうか？私の選択した方法はあまり聞き慣れない<a href="https://github.com/sstephenson/stitch">Stitch</a>ライブラリです。StichはSam Stephensonにより開発され、色々な物の中でも<a href="http://www.prototypejs.org">Prototype.js</a>の影響を受け、モジュールの問題をとてもエレガントに解決するので私は喜びのダンスを踊りたくなります！依存性を動的に解決するのではなく、Stichは単純にあなたのJavaScriptファイル全てを1つに結合します。それらをCommonJSの魔法で包みます。あぁ、 そういえばこれはお伝えしましたでしょうか？CoffeeScriptやJSテンプレート、<a href="http://lesscss.org">LESS CSS</a> それに <a href="http://sass-lang.com">Sass</a>ファイルもコンパイルします！</p>

<p>物事には順序があります。まず<a href="http://nodejs.org/">node.js</a> と <a href="http://npmjs.org/">npm</a>をまだお持ちでないのならインストールする必要があります。私達はこれからこの章を通してそれらを使用します。</p>

<p>それでは私達のアプリケーションの構造を作りましょう。もし<a href="https://github.com/maccman/spine">Spine</a>をお使いでしたら<a href="http://github.com/maccman/spine.app">Spine.App</a>を用いてこれを自動化できます。そうでなければこれは手動で行わねばなりません。私は通常、<code>app</code>フォルダを全てのアプリケーション特有のコードのために用意します。そして<code>lib</code>フォルダを一般的なライブラリのために作ります。他の物は全て静的なリソースも含めて<code>public</code>ディレクトリに入れましょう。</p>

<pre><code>app
app/controllers
app/views
app/models
app/lib
lib
public
public/index.html
</code></pre>

<p>それではStichサーバを実際に起動します。<code>index.coffee</code>という名のファイルを作り、次のスクリプトを入力してください。</p>

<p><span class="csscript"></span></p>

<pre><code>require("coffee-script")
stitch  = require("stitch")
express = require("express")
argv    = process.argv.slice(2)

package = stitch.createPackage(
  # Stitchに自動的に結合して欲しいパスを指定する
  paths: [ __dirname + "/app" ]

  # ベースとなるライブラリを指定する
  dependencies: [
    # __dirname + '/lib/jquery.js'
  ]
)
app = express.createServer()

app.configure -&gt;
  app.set "views", __dirname + "/views"
  app.use app.router
  app.use express.static(__dirname + "/public")
  app.get "/application.js", package.createServer()

port = argv[0] or process.env.PORT or 9294
console.log "Starting server on port: #{port}"
app.listen port
</code></pre>

<p>いくつかの依存ライブラリ、<code>coffee-script</code>, <code>stich</code>, そして<code>express</code>が並べられているのが見えますでしょうか？ 我々は<code>package.json</code>ファイルを作成し、これらの依存性を記述せねばなりません。そうすることでnpmがそれらを取り上げることができます。我々の<code>./package.js</code>ファイルは次のようになります。</p>

<pre><code>{
  "name": "app",
  "version": "0.0.1",
  "dependencies": { 
    "coffee-script": "~1.1.2",
    "stitch": "~0.3.2",
    "express": "~2.5.0",
    "eco": "1.1.0-rc-1"
  }
}
</code></pre>

<p>それではnpmを用いて依存ライブラリをインストールしましょう。</p>

<pre><code>npm install .
npm install -g coffee-script
</code></pre>

<p>OK.もうそこまで来ました。それでは次を実行します。</p>

<pre><code>coffee index.coffee
</code></pre>

<p>うまくいけばStitchサーバが立ち上がるでしょう。それでは先に進み<code>app</code>フォルダの中の<code>app.coffee</code>スクリプトを与えてテストしてみましょう。このファイルは私達のアプリケーションを起動するものになります。</p>

<p><span class="csscript"></span></p>

<pre><code>module.exports = App =
  init: -&gt;
    # アプリケーションを起動する
</code></pre>

<p>次にメインページとなる<code>index.html</code>を作成します。もし我々がシングルページアプリを作るのならば、ユーザがアクセスする唯一のページとなるでしょう。これは静的なリソースですから<code>public</code>の下に置きます。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=utf-8&gt;
  &lt;title&gt;Application&lt;/title&gt;
  &lt;!-- Stitchのメインファイルを必要とする --&gt;
  &lt;script src="/application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8"&gt;
    document.addEventListener("DOMContentLoaded", function(){
      var App = require("app");
      App.init();
    }, false);
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>ページがロードされた時、<em>DOMContentLoaded</em>イベントコールバックは<code>app.coffee</code>スクリプトをrequireします。(それは自動的にコンパイルされます。) 次に<code>init()</code>関数を実行します。あるべきものはそれだけです。私達は既にCommonJSモジュールを起動して実行しています。HTTPサーバとCoffeeScriptコンパイラもです。例えばもしモジュールをインクルードしたい場合、<code>require()</code>を呼ぶだけです。新しいクラス、<code>user</code>を作り、<code>app.coffee</code>から参照してみましょう。</p>

<p><span class="csscript"></span></p>

<pre><code># app/models/user.coffee
module.exports = class User
  constructor: (@name) -&gt;

# app/app.coffee
User = require("models/user")
</code></pre>

<h2>JavaScriptテンプレート</h2>

<p>ロジックをクライアントサイドに動かしたい場合、あなたは間違いなく何らかのテンプレートライブラリを必要とするでしょう。JavaScriptテンプレートはサーバのテンプレートとほぼ同じものです。例えばRubyのERBやPythonのテキスト内挿法のようなものでもちろんクライアントサイドでも動作します。世の中には数多くのテンプレートライブラリがあります。そのため私はあなたにいくらかの調査と試用を行うことをお勧めします。Stitchはデフォルトでは<a href="https://github.com/sstephenson/eco">Eco</a>テンプレートを内部に持っています。</p>

<p>JavaScriptテンプレートはサーバサイドのそれと似たようなものです。HTMLの中にテンプレートタグを挿入し、描画の間にそれらのタグが評価され置換されます。<a href="https://github.com/sstephenson/eco">Eco</a>テンプレートの優れている点はテンプレートタグが実はCoffeeScriptで記述されていることです。</p>

<p>例を見てみましょう</p>

<pre><code>&lt;% if @projects.length: %&gt;
  &lt;% for project in @projects: %&gt;
    &lt;a href="&lt;%= project.url %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
    &lt;p&gt;&lt;%= project.description %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% else: %&gt;
  No projects
&lt;% end %&gt;
</code></pre>

<p>ご覧のとおり、文法は際立って直接的です。ただ<code>&lt;%</code>タグを使って式を評価し、<code>&lt;%=</code>タグは表示のために用います。テンプレートタグの一部のリストは次のとおりです。</p>

<ul>
<li><p><code>&lt;% expression %&gt;</code><br/>
CoffeeScriptの式を評価する。その返り値はプリントしない。</p></li>
<li><p><code>&lt;%= expression %&gt;</code><br/>
CoffeeScriptの式を評価する。その返り値をエスケープし、プリントする。</p></li>
<li><p><code>&lt;%- expression %&gt;</code><br/>
CoffeeScriptの式を評価し、その返り値をエスケープせずにプリントする。</p></li>
</ul>


<p>任意のCoffeeScriptの式をテンプレートタグの中で使用することが可能ですが、気をつけることが1つだけあります。CoffeeScriptは空白に敏感です。しかしEcoテンプレートはそうではありません。従ってインデントされたCoffeeScriptブロックを始めるEcoテンプレートタグはコロンを追加せねばなりません。インデントブロックの終わりを示すには特別なタグ<code>&lt;% end %&gt;</code>を使用します。次の例をご覧下さい。</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt;
  On Hold
&lt;% end %&gt;
</code></pre>

<p><code>if</code>と<code>end</code>のタグを行を分けて書く必要はありません。</p>

<pre><code>&lt;% if @project.isOnHold(): %&gt; On Hold &lt;% end %&gt;
</code></pre>

<p>ご期待通り、1行で書くための後置形式も利用可能です。</p>

<pre><code>&lt;%= "On Hold" if @project.isOnHold() %&gt;
</code></pre>

<p>さて文法については取っ掛かりを得ました。<code>views/users/show.eco</code>の中にEcoテンプレートを定義しましょう。</p>

<pre><code>&lt;label&gt;Name: &lt;%= @name %&gt;&lt;/label&gt;
</code></pre>

<p>Stichは自動的に私達のテンプレートをコンパイルして<code>application.js</code>に含めてしまいます。そして私達のアプリケーションのコントローラではテンプレートをrequireすることがモジュールのように可能で、必要なデータを渡して実行することができます。</p>

<p><span class="csscript"></span></p>

<pre><code>require("views/users/show")(new User("Brian"))
</code></pre>

<p>私達の<code>app.coffee</code>ファイルは以下のようになっているはずです。テンプレートを描画し、ドキュメントがロードされた時にページに対して追加します。</p>

<p><span class="csscript"></span></p>

<pre><code>User = require("models/user")

App =
  init: -&gt;
    template = require("views/users/show")
    view     = template(new User("Brian"))

    # 明らかにこれはjQueryを用いて綺麗にできるでしょう
    element = document.createElement("div")
    element.innerHTML = view
    document.body.appendChild(element)

module.exports = App
</code></pre>

<p><a href="http://localhost:9294/">アプリケーション</a>を開いて試してみてください。願わくばこのチュートリアルがクライアントサイドのCoffeeScriptアプリケーションをどう構造化するについて良いアイデアを与えていることを期待します。次のステップとして、私はクライアントサイドフレームワークをチェックすることをお勧めします。例えば<a href="http://documentcloud.github.com/backbone/">Backbone</a> or <a href="http://spinejs.com">Spine</a>などです。それらは基本的なMVC構造を与え、あなたをより面白い仕事へと解放します。</p>

<h2>ボーナス - 30秒でHerokuへデプロイ</h2>

<p><a href="http://heroku.com">Heroku</a>は信じられないほど最高なWebホストで全てのサーバを管理し、スケールし、あなたがエキサイティングな物(素晴しいJavaScriptアプリケーションを構築すること)と共に乗り込むことを可能にします。このチュートリアルを行うにはHerokuのアカウントを必要とします。しかしうれしいことにHerokuのベーシックプランは完全に無料です。元々はRubyのホストでしたが、Herokuは最近、Cedarスタックをリリースし、それにはnodeサポートを含んでいます。</p>

<p>最初に<code>Procfile</code>を作ります。これはHerokuに我々のアプリケーションについて伝えます。</p>

<pre><code>echo "web: coffee index.coffee" &gt; Procfile
</code></pre>

<p>まだお済みでなければあなたのアプリケーションに対しローカルgitリポジトリを作成して下さい。</p>

<pre><code>git init
git add .
git commit -m "First commit"    
</code></pre>

<p>それではアプリケーションをデプロイしましょう。<code>heroku</code>コマンドを使います。(まだインストールしていなければする必要があります。)</p>

<pre><code>heroku create myAppName --stack cedar
git push heroku master
heroku open
</code></pre>

<p>以上です！ 本当にこれだけなんです。nodeアプリケーションをホスティングすることはこれ以上には簡単にならないでしょう。</p>

<h2>追加のライブラリ</h2>

<p><a href="https://github.com/sstephenson/stitch">Stitch</a> と <a href="https://github.com/sstephenson/eco">Eco</a>だけがCoffeeScriptとnodeのアプリケーションを作るのに利用可能なライブラリではありません。他にも各種あります。</p>

<p>例えばテンプレートに関しては<a href="http://mustache.github.com">Mustache</a>, <a href="http://jade-lang.com">Jade</a> または純粋にCoffeeScriptを使ってHTMLを書く<a href="http://coffeekup.org">CoffeeKup</a>もあります。</p>

<p>アプリケーションの提供に関しては<a href="http://github.com/maccman/hem">Hem</a>は良い選択です。CommonJSとNPMモジュールの両方をサポートし、CoffeeScriptのMVCフレームワークである<a href="http://spinejs.com">Spine</a>とシームレスに結合できます。<a href="https://github.com/substack/node-browserify">node-browsify</a>も同様のプロジェクトです。もし<a href="http://expressjs.com/">express</a>を用いて低レベルの結合をしたい場合にはTrevor Burnhamの <a href="https://github.com/TrevorBurnham/connect-assets">connect-assets</a>もあります。</p>

<p>CoffeeScriptのWebフレームワークプラグインの完全なリストは<a href="https://github.com/jashkenas/coffee-script/wiki/Web-framework-plugins">project's wiki</a>にあります。</p>

  </div>
</div>
</body>
</html><!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>The Little Book on CoffeeScript - The Bad Parts</title>
<link rel="stylesheet" href="site/site.css" type="text/css" charset="utf-8">
<link rel="stylesheet" href="site/highlight.css" type="text/css" charset="utf-8">
<script src="site/jquery.js" type="text/javascript" charset="utf-8"></script>      
<script src="site/highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="site/coffee-script.js" type="text/javascript" charset="utf-8"></script>
<script src="site/preview.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
  hljs.initHighlightingOnLoad();
</script>
</head>
<body>
<div id="container">
  <header>
    <h1><a href="index.html">The Little Book on CoffeeScript</a></h1>
  </header>
  
  <div id="content">
    <div class="back"><a href="index.html">&laquo; 索引に戻る</a></div>


<h1>The Bad Parts: 悪い所</h1>

<p>JavaScriptは狡猾な猛獣です。あなたにとって避けるべき部分を知ることは使うべき部分を知ることと同じくらい重要です。孫子は"己の敵を知れ"と言いました。それは完全に私達がこれからこの章で行おうとしていることです。JavaSriptの闇の側面を探検すると、疑うことを知らない開発者を急襲するのに準備万端なモンスター達が潜んでいます。全てを陽の下に晒しましょう。</p>

<p>イントロで説明しましたとおり、CoffeeScriptの良さはその文法だけでなく、JavaScriptの欠点を直す能力にあります。しかしCoffeeScriptの文は直接JavaScriptに翻訳され、仮想機械やインタプリタ上で実行される訳ではないため、CoffeeScriptは全てのJavaScriptの恐怖に対する銀の弾丸ではなく、注意しなければならない問題がまだあります。</p>

<p>最初にCoffeeScriptが何を解決するかを話しましょう。</p>

<h2>JavaScriptの部分集合</h2>

<p>CoffeeScriptの文法はJavaScriptの部分集合をカバーするのみです。著名な<em>Good Parts</em>です。したがって既に直すものはほとんどありません。例として<code>with</code>文について考えましょう。この文は長い間"有害である(Considered harmful)"とされ、避けるべきものでした。<code>with</code>はオブジェクトに対するプロパティ操作の記述の繰返しに対する構文糖を提供することを狙っていました。次の例をご覧下さい。</p>

<pre><code>dataObj.users.alex.email = "info@eribium.org";
</code></pre>

<p>上は以下のように書けます。</p>

<pre><code>with(dataObj.users.alex) {
  email = "info@eribium.org";
}
</code></pre>

<p>実際に最初からそんな深いオブジェクトを持つべきでないのは置いておいて、この文法はとても簡潔です。ただし1つの例外がありました。これはとてもJavaScriptインタプリタにとって混乱の元だったのです。インタプリタはあなたが<code>with</code>の中で何をするつもりなのかわかりません。そこで全ての名前解決を最初に特定のオブジェクトに対して行うよう強制しました。</p>

<p>これは本当にパフォーマンスに悪影響を与え、インタプリタにはJIT最適化の類を全てオフにすることを強制しました。加えて<code>with</code>文は<a href="https://github.com/mishoo/UglifyJS">uglify-js</a>のようなツールを用いて最小化を行なうことが不可能でした。<code>with</code>は将来のJavaScriptのバージョンでは非推奨となり、削除されます。考慮すべきことは、それを使わないことを考えたほうがずっと良いということです。CoffeeScriptはさらに進めてそれを文法から消してしまいました。CoffeeScriptで<code>with</code>を使うとシンタックスエラーになります。</p>

<h2>大域変数</h2>

<p>デフォルトではJavaScriptのプログラムはグローバルスコープで実行されます。そしてデフォルトでは全ての変数はグローバルスコープにて作成されます。もし変数をローカルスコープで作成したければJavaScriptでは<code>var</code>キーワードを用いてその意思を示さねばなりません。</p>

<pre><code>usersCount = 1;        // Global
var groupsCount = 2;   // Global

(function(){              
  pagesCount = 3;      // Global
  var postsCount = 4;  // Local
})()
</code></pre>

<p>これは少しおかしな決定です。なぜならほとんど多くの場合、あなたが作るのはローカル変数であり、グローバルではないからです。ですからそれをデフォルトにしてはどうでしょうか？現状では開発者は<code>var</code>文を全ての変数の前に、初期化時に置くことを覚えなければなりません。そうしなければ変数名が不注意で衝突しお互いを上書きした時に、変なバグに直面することでしょう。</p>

<p>幸運なことにCoffeeScriptがここではあなたの助けとなります。暗黙のグローバル変数宣言を完全に消しました。言い方を変えれば<code>var</code>キーワードはCoffeeScriptでは予約語ですが、もし使用するとシンタックスエラーとなります。ローカル変数が暗黙的にデフォルトで作成されます。明示的に<code>window</code>のプロパティとして割り当てない限り、グローバル変数を作ることはとても難しいです。</p>

<p>CoffeeScriptの変数宣言の例を見てみましょう。</p>

<p><span class="csscript"></span></p>

<pre><code>outerScope = true
do -&gt;
  innerScope = true
</code></pre>

<p>上の例は以下のようにコンパイルされます。</p>

<pre><code>var outerScope;
outerScope = true;
(function() {
  var innerScope;
  return innerScope = true;
})();
</code></pre>

<p>CoffeeScriptがどのように(<code>var</code>を用いて)変数を自動的にそれが最初に使用されたコンテキストで初期化するかご覧下さい。外部の変数を覆い隠すのは無理ですが、それらを参照し、アクセスすることは可能です。これには注意が必要です。深くネストする関数やクラスを書く場合に、不注意で外部の変数の名前を再利用しないように気を付けてください。例えば次の例では不注意でClass関数の<code>package</code>変数を上書きしています。</p>

<p><span class="csscript"></span></p>

<pre><code>package = require('./package')

class Hem
  build: -&gt;
    # 外部変数を上書きしてる!!
    package = @hemPackage.compile()

  hemPackage: -&gt;
    package.create()
</code></pre>

<p>グローバル変数は時には必要です。作成するには<code>window</code>のプロパティとして設定する必要があります。</p>

<p><span class="csscript"></span></p>

<pre><code>  class window.Asset
    constructor: -&gt;
</code></pre>

<p>グローバル変数が暗黙的でなく明示的であることで、CoffeeScriptはJavaScriptプログラムのバグの原因の主な一つを消しています。</p>

<h2>セミコロン</h2>

<p>JavaScriptはセミコロンの使用をソースコード内で強制はしません。よって省略可能です。しかし、裏側ではJavaScriptコンパイラはそれを必要としています。そのためパーサはセミコロンが無いために起こるパースエラーが発生する度に、自動的にセミコロンを挿入しています。言い替えると文をセミコロン無しで評価し、もしそれが失敗したらセミコロンを用いて再評価を試します。</p>

<p>不幸なことに、これは途方もなく悪い考えでした。実際にあなたのコードの挙動を変えてしまいます。次の例を見てください。正しいJavaScriptに見えるでしょう？ でも本当に？</p>

<pre><code>function() {}
(window.options || {}).property
</code></pre>

<p>誤りです。少なくともパーサに従えばシンタックスエラーを出します。先の括弧に対し、パーサはセミコロンを挿入しません。コードは1行に変換されます。</p>

<pre><code>function() {}(window.options || {}).property
</code></pre>

<p>もう問題がおわかりになるでしょう。そしてなぜパーサが文句を言うのかも。JavaScriptを書くときに常に文の最後にセミコロンを置くべきです。幸いなことに、CoffeeScriptはこの問題に対しその文法にセミコロンを持たないことで対処しました。正確に言えばCoffeeScriptがJavaScriptにコンパイルされる時に、(正確な場所に)セミコロンが自動的に挿入されます。</p>

<h2>予約語</h2>

<p>いくつかのJavaScriptのキーワードは将来のJavaScriptのバージョンのために予約されています。例えば<code>const</code>や<code>enum</code>、<code>class</code>です。これらを変数名としてJavaScriptプログラムにて使用すると予測できない結果が起こり得ます。あるブラウザはこれに問題なく対処できますが、他のブラウザでは首を締めます。CoffeeScriptはこの問題をうまく回避します。予約語の使用を見つけると必要な場合にはエスケープします。</p>

<p>例として<code>class</code>という予約語をオブジェクトのプロパティとして利用するとしましょう。CoffeeScriptは次のようになります。</p>

<p><span class="csscript"></span></p>

<pre><code>myObj = {
  delete: "I am a keyword!"
}
myObj.class = -&gt;
</code></pre>

<p>CoffeeScriptのパーサはあなたが予約語を使用していることを見つけ括ってくれます。</p>

<pre><code>var myObj;
myObj = {
  "delete": "I am a keyword!"
};
myObj["class"] = function() {};
</code></pre>

<h2>等価比較</h2>

<p>javascriptの弱い等価比較(<code>==</code>)は人を混乱させる挙動があり、しばしばバグの温床となっています。下の例は<a href="http://bonsaiden.github.com/javascript-garden/#types.equality">javascript garden's equality section</a>からの引用ですが、問題についてある深さまで掘り下げています。</p>

<p><span class="csscript"></span></p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>この挙動の理由は弱い等価比較は自動的に型変換を強制します。この結果はとても不明瞭で、予測できない結果とバグの原因になるという意見にあなたもきっと同意してくれるでしょう。</p>

<p>解決方法は代わりに厳密な等価演算子を用いることです。それは3つの＝記号から成ります(<code>===</code>)。これは普通の等価演算子と全く同じように働きますが、型の強制変換を行いません。常に厳密な等価演算子を使い、必要な場合には明示的に型を変換することが推奨されています。</p>

<p>CoffeeScriptではこれを単純に全ての弱い等価比較を厳密なものに置き換えることで解決します。つまり全ての<code>==</code>比較演算子を<code>===</code>に取り替えます。CoffeeScriptでは弱い等価比較は使えません。そしてもし必要であれば比較する前に明示的に型を変換しなければなりません。</p>

<p>しかし、これはCoffeeScriptで常に型の強制変換を完璧に無視できるということではありません。特にフローコントロールにおける変数の真偽値のチェックにおいて顕著です。空文字列、<code>null</code>、<code>undefined</code>、それに数値の<code>0</code>は<code>false</code>に変換されます。</p>

<p><span class="csscript"></span></p>

<pre><code>alert("空配列")      unless [].length
alert("空文字列")    unless ""
alert("数値の0")     unless 0
</code></pre>

<p>もし明示的に<code>null</code>と<code>undefined</code>をチェックしたい場合には、CoffeeScriptの存在確認演算子を利用可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>alert("これは呼ばれない") unless ""?
</code></pre>

<p>この例の<code>alert()</code>は呼ばれません。空文字列は<code>null</code>とは等しくないためです。</p>

<h2>関数定義</h2>

<p>JavaScriptでは十分に変なことに、関数が使用後に定義可能です。次の例をご覧ください。これは全く問題なく実行できます。<code>wem</code>が呼ばれた後に定義されているのにです。</p>

<pre><code>wem();
function wem() {}
</code></pre>

<p>これは関数スコープのためです。関数はプログラムの実行前に引き上げられます。そのようなものとしてそれが定義されたスコープの中ではどこでも有効です。</p>

<pre><code>if (true) {
  function declaration() {
    return "first";
  }
} else {
  function declaration() {
    return "second";
  }
}
declaration();
</code></pre>

<p>いくつかのブラウザ、例えばFirefoxでは<code>declaration()</code>は<code>"first"</code>を返します。そして他のブラウザ、例えばChromeでは例え<code>else</code>節が永久に実行されないように見えても<code>"second"</code>を返します。</p>

<p>もし宣言的な関数についてより知りたいのであれば、<a href="http://kangax.github.com/nfe/">Juriy Zaytsevのガイド</a>を読むべきです。彼は仕様について掘り下げました。それらはとても不明瞭な挙動を持ち、いつか後に問題の発端となるだろうと言うだけで十分でしょう。全てを考慮に入れて、それらの問題を解決するには代わりに関数式を用いるのが最良でしょう。</p>

<pre><code>var wem = function(){};
wem();
</code></pre>

<p>CoffeeScriptのこの問題に対するアプローチは宣言的関数を全体的に取り除くことでした。関数式のみを用います。</p>

<h2>数値のプロパティを参照する</h2>

<p>JavaScriptパーサの問題として数値に対する<em>ドット表記</em>がプロパティの参照でなく浮動小数点記述だと翻訳されることでしょう。次の例をご覧下さい。次のJavaScriptはシンタックスエラーとなります。</p>

<pre><code>5.toString();
</code></pre>

<p>JavaScriptのパーサはドットの後ろに別の数値を探します。そして<code>toString()</code>に出くわした時に<code>Unexpected token</code>エラーを起こします。これに対する解決法は括弧を用いるか、追加のドットを足すことです。</p>

<pre><code>(5).toString();
5..toString();
</code></pre>

<p>幸い、CoffeeScriptのパーサはこの問題に対処するに十分に賢く、数値のプロパティにアクセスする場合全てにおいて、上の例に対しても自動的に、2つのドット表記を用います。</p>

<h1>直されていない部分</h1>

<p>CoffeeScriptがJavaScriptの設計上の問題に対し、いくらかの解決法を提供しているにせよ、ここまでの程度になります。先にお伝えしたとおり、CoffeeScriptは設計上、静的解析に厳密に制限されています。実行時チェックはパフォーマンスを理由に全く行っていません。CoffeeScriptはソース・トゥ・ソースなコンパイラであり、そのアイデアは「全てのCoffeeScriptの文は等価なJavaScriptの文に置き換わる」です。CoffeeScriptは例えば<code>typeof</code>のようなJavaScriptのキーワードのどれ1つにも抽象化を与えず、そのようなものとするので、JavaScriptの設計上の問題のいくつかはCoffeeScriptにもそのまま当て嵌ります。</p>

<p>先のセクションで、CoffeeScriptが直したJavaScriptの設計上の問題について説明しました。ここからはCoffeeScriptが直していないJavaScriptの問題について話しましょう。</p>

<h2>evalの使用</h2>

<p>CoffeeScriptはJavaScriptのいくつかの欠点を無くしましたが、他の機能は必要悪です。あなたはそれらの欠点について注意しなければなりません。該当する例は<code>eval()</code>関数です。疑いなくそれにはその用途があります。しかしあなたはその欠点も知る必要があります。そして可能なら防がなければなりません。<code>eval()</code>関数はJavaScriptコードの文字列をローカルスコープにて実行します。また<code>setTimeout()</code>や<code>setInterval()</code>といった関数もまた最初の引数として文字列を取り、評価します。</p>

<p>しかし<code>with</code>のように、<code>eval()</code>はコンパイラから手掛かりを失わせます。パフォーマンスを悪くする主な原因です。コンパイラには実行時に中身に何が入っているかは検討もつきません。インライン展開のような最適化を実行することも不可能です。もう1つの憂慮点はセキュリティです。もし精査していない入力を与えれば<code>eval</code>は簡単にあなたのコードをインジェクション攻撃に対し無力にします。あなたが<code>eval</code>を使用する場合の99%にはより良く、より安全な、(角括弧のような)代替法があります。</p>

<p><span class="csscript"></span></p>

<pre><code># やってはいけません
model = eval(modelName)

# 代わりに角括弧を使いましょう
model = window[modelName]
</code></pre>

<h2>typeofを使う</h2>

<p><code>typeof</code>演算子は恐らく最も大きなJavaScriptの設計上の問題でしょう。なぜなら基本的に完全に壊れているからです。実際にそれの用途は本当に1つしかありません。値が<code>undefined</code>であるかチェックすることです。</p>

<p><span class="csscript"></span></p>

<pre><code>typeof undefinedVar is "undefined"
</code></pre>

<p>他のタイプの型チェックに関しては<code>typeof</code>はとても惨めに失敗します。ブラウザの種類とインスタンスがどのようにインスタンス化されたかにより異なった結果を返します。これはCoffeeScriptでもあなたを助けることができません。なぜならCoffeeScriptは静的解析のみを用いており、実行時の型チェックを持たないからです。ここで頼れるのはあなただけです。</p>

<p>問題をはっきりさせるために、<a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript Garden</a>から引用した表を用意しました。これはキーワードの型チェックにおける主な不安定さを表示します。</p>

<pre><code>値                  クラス     型
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object
new RegExp("meow")  RegExp     object
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>ご覧のとおり、文字列をクォートで括るか、<code>String</code>クラスで定義するかが<code>typeof</code>の結果に影響します。論理的には<code>typeof</code>は<code>"string"</code>を両者のチェックに対し返すべきです。しかし後者には<code>"object"</code>を返します。不幸なことに不安定さはそこからさらに悪くなります。</p>

<p>それではJavaScriptにおける型チェックには何を使えるのでしょうか？幸運なことに<code>Object.prototype.toString()</code>がここでは救いとなります。この関数を適切なオブジェクトのコンテキストで実行した場合、正しい型を返します。やらねばならぬ事は返り値をマッサージして、<code>typeof</code>が本来返すべきだった値のような文字列にすることです。次のコードはjQueryの<code>$.type</code>から移植した実装例です。</p>

<p><span class="csscript"></span></p>

<pre><code>type = do -&gt;
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  (obj) -&gt;
    strType = Object::toString.call(obj)
    classToType[strType] or "object"

# 期待する型を返します
type("")         # "string"
type(new String) # "string"
type([])         # "array"
type(/\d/)       # "regexp"
type(new Date)   # "date"
type(true)       # "boolean"
type(null)       # "null"
type({})         # "object"
</code></pre>

<p>もし変数が既に定義済みであるかを調べたいのならば、今でも<code>typeof</code>を使用する必要があります。そうしなければ<code>ReferenceError</code>を受け取ることになるでしょう。</p>

<p><span class="csscript"></span></p>

<pre><code>if typeof aVar isnt "undefined"
  objectType = type(aVar)
</code></pre>

<p>またはより簡潔に存在確認演算子を用います。</p>

<pre><code>objectType = type(aVar?)
</code></pre>

<p>As an alternative to type checking, you can often use duck typing and the CoffeeScript existential operator together to eliminating the need to resolve an object's type. For example, let's say we're pushing a value onto an array. We could say that, as long as the 'array like' object implements <code>push()</code>, we should treat it like an array:
型チェックの代わりに、しばしばダックタイピングとCoffeeScriptの存在確認演算子を一緒に用いることでオブジェクトの型を解く必要を無くすことが可能です。例として、配列に値をプッシュするとしましょう。こう言うことができます。「もし<code>array</code>であるかのようなオブジェクトが<code>push()</code>を実装しているのであれば、それを配列として扱うべきだろう。」</p>

<p><span class="csscript"></span></p>

<pre><code>anArray?.push? aValue
</code></pre>

<p>もし<code>anArray</code>が配列ではないオブジェクトだとしても、存在確認演算子が<code>push()</code>が呼ばれないことを保障します。</p>

<h2>instanceofの使用</h2>

<p>JavaScriptの<code>instanceof</code>キーワードは<code>typeof</code>のようにほとんど壊れています。理想的には<code>instanceof</code>は2つのオブジェクトのコンストラクタを比較し、一方が他方のインスタンスであるかの真偽値を返すはずです。しかし実際には<code>instanceof</code>はカスタムメイドのオブジェクトを比較する場合のみ、うまく動作します。ビルトインタイプを比較する場合には<code>typeof</code>と同じように使いものになりません。</p>

<p><span class="csscript"></span></p>

<pre><code>new String("foo") instanceof String # true
"foo" instanceof String             # false
</code></pre>

<p>さらに<code>instanceof</code>はまた、ブラウザの異なるフレームからのオブジェクトを比較する場合に動作しません。実際に<code>instanceof</code>はカスタムメイドのオブジェクトに対してのみ正しい結果を返します。例えばCoffeeScriptのクラスです。</p>

<p><span class="csscript"></span></p>

<pre><code>class Parent
class Child extends Parent

child = new Child
child instanceof Child  # true
child instanceof Parent # true
</code></pre>

<p>あなた自身が作成したオブジェクトに用いるか、より良くは、無かったことにしましょう。</p>

<h2>deleteの使用</h2>

<p><code>delete</code>キーワードはオブジェクトの中のプロパティを消去する場合にだけ安全に使用可能です。</p>

<p><span class="csscript"></span></p>

<pre><code>anObject = {one: 1, two: 2}
delete anObject.one
anObject.hasOwnProperty("one") # false
</code></pre>

<p>他のどんな使用も、例えば変数や関数を消す場合はうまくいきません。</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
delete aVar
typeof Var # "integer"
</code></pre>

<p>とても奇妙な挙動ですが、とにかく動作はしました。もし変数への参照を消したいのであれば、ただ代わりに<code>null</code>を代入しましょう。</p>

<p><span class="csscript"></span></p>

<pre><code>aVar = 1
aVar = null
</code></pre>

<h2>parseIntの使用</h2>

<p>JavaScriptの<code>parseInt()</code>関数は適切な基数を与えずに文字列を与えると思いもよらない結果を返します。</p>

<pre><code># 8を返します。10でなく!
parseInt('010') is 8
</code></pre>

<p>常に基数を関数に渡して正しく動作するようにしましょう。</p>

<pre><code># 10を基数として用いることで正しい結果に
parseInt('010', 10) is 10
</code></pre>

<p>これはCoffeeScriptがどうにかしてあげられることではありません。<code>parseInt()</code>を用いる場合には必ず基数を指示することを覚えなければなりません。</p>

<h2>ストリクトモード</h2>

<p>ストリクトモードはECMAScript 5の新しい機能で、JavaScriptプログラムや関数を<em>strict</em>なコンテキストで実行することを許可します。このストリクトなコンテキストではより多くの例外や警告を通常のコンテキストに比べて投げるようになります。開発者に対しベストプラクティスから離れた場合や、最適化不能なコードや一般的な間違いを犯した場合に目安のようなものを与えます。つまりストリクトモードはバグを減らし、セキュリティを向上し、パフォーマンスも向上し、言語機能を用いるにおいての難しさを解消します。誰も嫌わないでしょう？</p>

<p>ストリクトモードは執筆時現在では次のブラウザでサポートされています。</p>

<ul>
<li>Chrome >= 13.0</li>
<li>Safari >= 5.0</li>
<li>Opera >= 12.0</li>
<li>Firefox >= 4.0</li>
<li>IE >= 10.0</li>
</ul>


<p>そうはいってもストリクトモードは完全に後方互換性が古いブラウザに対してあります。それを用いたプログラムはストリクトとノーマルの両方のコンテキストで問題なく動作するはずです。</p>

<h3>ストリクトモードでの変化</h3>

<p>ストリクトモードの変更のほとんどはJavaScriptの文法に関連するものです。</p>

<ul>
<li>プロパティと関数引数名の複製のエラー</li>
<li>不正な<code>delete</code>演算子の使用上のエラー</li>
<li><code>arguments.caller</code>と<code>arguments.callee</code>へのアクセスはエラーを投げる。(パフォーマンス上の理由で)</li>
<li><code>with</code>演算子を使用するとシンタックスエラーを上げる</li>
<li><code>undefined</code>のような変数には最早書込不可である</li>
<li>追加の予約語が増える。例えば<code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, <code>yield</code></li>
</ul>


<p>しかし、ストリクトモードはまた実行時の挙動にも変更があります。</p>

<ul>
<li>グローバル変数が明示的になり、<code>var</code>が常に要求される。<code>this</code>のグローバルでの値は<code>undefined</code></li>
<li><code>eval</code>はローカルコンテキストに新しい変数を追加できない</li>
<li>関数は使用される前に定義されねばならない。(以前は<a href="http://whereswalden.com/2011/01/24/new-es5-strict-mode-requirement-function-statements-not-at-top-level-of-a-program-or-function-are-prohibited/">関数はどこで定義しても良かった</a>)。</li>
<li><code>arguments</code>は変更不可(インミュータブル)</li>
</ul>


<p>CoffeeScript already abides by a lot of strict mode's requirements, such as always using <code>var</code> when defining variables, but it's still very useful to enable strict mode in your CoffeeScript programs. Indeed, CoffeeScript is taking this a step further and in <a href="https://github.com/jashkenas/coffee-script/issues/1547">future versions</a> will check a program's compliance to strict mode at compile time.
CoffeeScriptは既にストリクトモードの要求の多くを遵守しています。例えば変数定義では常に<code>var</code>を用います。しかしそれでもあなたのCoffeeScriptプログラムにおいてストリクトモードを許可するのはとても有益です。実際にCoffeeScriptはこれをより一歩進めて、<a href="https://github.com/jashkenas/coffee-script/issues/1547">将来のバージョン</a>ではコンパイル時にストリクトモードに対する整合性をチェックするようになります。</p>

<h3>ストリクトモードの使用</h3>

<p>ストリクトモードを使用するのに必要なことはスクリプトや関数を次の文字列で開始するだけです。</p>

<p><span class="csscript"></span></p>

<pre><code>-&gt;
  "use strict"

  # ... あなたのコード ...
</code></pre>

<p>これで全てです。<code>'use strict'</code>で始めるだけです。これ以上簡単にならないくらいですし、後方互換性も完璧にあります。実際にストリクトモードを見てみましょう。次の関数はストリクトモードではシンタックスエラーを上げます。しかし通常のモードでは問題なく動作します。</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  console.log(arguments.callee)
</code></pre>

<p>ストリクトモードでは<code>arguments.caller</code>と<code>arguments.callee</code>に対するアクセスを削除しました。それらはパフォーマンス悪化の主な原因であるためです。そしてそれらが使われる場合全てにおいてシンタックスエラーを上げます。</p>

<p>ストリクトモードを用いる場合に注意すべき心得があります。グローバル変数を作るときに<code>this</code>を用いる場合です。次の例は<code>TypeError</code>をストリクトモードでは投げます。しかし通常のコンテキストでは問題なく動作し、グローバル変数を作ります。</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class @Spine
</code></pre>

<p>裏側にあるこの違いの理由はストリクトモードでは<code>this</code>が<code>undefined</code>であるためです。通常では<code>window</code>オブジェクトを参照します。この問題の解決法は明示的に外部変数を<code>window</code>オブジェクトに対し設定することです。</p>

<p><span class="csscript"></span></p>

<pre><code>do -&gt;
  "use strict"
  class window.Spine
</code></pre>

<p>ストリクトモードを許可することをお勧めしましたが、ストリクトモードは何も新しい機能をJavaScriptで使用可能にはしません。それに実際にはコードのパフォーマンスを少しだけ遅くします。VMにより多くのチェックを実行時にさせるためです。ストリクトモードで開発を行い、運用ではそれを外すのも良いでしょう。</p>

<h2>JavaScript Lint</h2>

<p><a href="http://www.javascriptlint.com/">JavaScript Lint</a>はJavaScriptコードの品質チェックツールです。あなたのプログラムをLintに通してみることはコード品質を向上させるために最良の方法であり、ベストプラクティスでもあります。このプロジェクトは似たようなツールである<a href="http://www.jslint.com">JSLint</a>を基にしています。JSLintのサイトにあるチェック対象の問題の<a href="http://www.jslint.com/lint.html">リスト</a>を見てみてください。グローバル変数やセミコロンの存在や弱い等価比較などが含まれます。</p>

<p>良いニュースとして、CoffeeScriptは既に全ての出力に対して<code>lints</code>をかけています。従ってCoffeeScriptで生成されたJavaScriptは既にJavaScript Lint互換です。実際に<code>coffee</code>ツールは<code>--lint</code>オプションをサポートしています。</p>

<pre><code>coffee --lint index.coffee
  index.coffee: 0 error(s), 0 warning(s)
</code></pre>

  </div>
</div>
</body>
</html>